#!/usr/bin/env python3

import argparse
import copy
import itertools
import json
import logging
import os
import shlex
import subprocess
import sys

_logger = logging.getLogger(__file__)

def repr(object):
    return f"{object.__class__.__name__}({', '.join([f'{prop}={value}' for prop, value in object.__dict__.items()])})"

COLOR_GRAY = "\033[38;20m"
COLOR_RED = "\033[1;31m"
COLOR_YELLOW = "\033[1;33m"
COLOR_CYAN = "\033[0;36m"
COLOR_GREEN = "\033[0;32m"
COLOR_RESET = "\033[0;0m"

class ColoredLoggingFormatter(logging.Formatter):
    COLORS = {
        logging.DEBUG: COLOR_GREEN,
        logging.INFO: COLOR_GREEN,
        logging.WARNING: COLOR_YELLOW,
        logging.ERROR: COLOR_RED,
        logging.CRITICAL: COLOR_RED
    }

    def format(self, record):
        format = self.COLORS.get(record.levelno) + "%(levelname)s " + "%(message)s"
        formatter = logging.Formatter(format)
        return formatter.format(record)

def parse_arguments():
    description = "Sets up the development environment for OMNeT++ projects"
    parser = argparse.ArgumentParser(description=description)
    parser.add_argument("-l", "--log-level", choices=["ERROR", "WARN", "INFO", "DEBUG"], default="INFO", help="Verbose output mode")
    parser.add_argument("-w", "--workspace", dest="workspace_directory", help="Workspace directory")
    subparsers = parser.add_subparsers(title="subcommands", dest="subcommand", required=True)

    parser_list = subparsers.add_parser("list", help="Lists all available projects")

    parser_describe = subparsers.add_parser("describe", help="Describes the specified project")
    parser_describe.add_argument("project", help="The project name")

    parser_shell = subparsers.add_parser("build", help="Builds the specified projects in their environment")
    parser_shell.add_argument("projects", nargs="+", help="List of projects")
    parser_shell.add_argument("-i", "--isolated", action=argparse.BooleanOptionalAction, default=True, help="Run in isolated environment from the host operating system")

    parser_shell = subparsers.add_parser("clean", help="Cleans the specified projects in their environment")
    parser_shell.add_argument("projects", nargs="+", help="List of projects")
    parser_shell.add_argument("-i", "--isolated", action=argparse.BooleanOptionalAction, default=True, help="Run in isolated environment from the host operating system")

    parser_shell = subparsers.add_parser("shell", help="Runs a shell in the environment of the specified projects")
    parser_shell.add_argument("projects", nargs="+", help="List of projects")
    parser_shell.add_argument("-i", "--isolated", action=argparse.BooleanOptionalAction, default=True, help="Run in isolated environment from the host operating system")

    parser_run = subparsers.add_parser("run", help="Runs a command in the environment of the specified projects")
    parser_run.add_argument("projects", nargs="+", help="List of projects")
    parser_run.add_argument("-i", "--isolated", action=argparse.BooleanOptionalAction, default=True, help="Run in isolated environment from the host operating system")
    parser_run.add_argument("-c", "--command", help="Specifies the commmand that is run in the environment")

    return parser.parse_args(sys.argv[1:])

def process_arguments():
    args = parse_arguments()
    handler = logging.StreamHandler()
    handler.setFormatter(ColoredLoggingFormatter())
    _logger.setLevel(args.log_level)
    _logger.handlers = []
    _logger.addHandler(handler)
    kwargs = {k: v for k, v in vars(args).items() if v is not None}
    if "workspace_directory" in kwargs:
        kwargs["workspace_directory"] = os.path.abspath(kwargs["workspace_directory"])
    return kwargs

def run_command(command):
    _logger.debug(f"Running command: {command}")
    result = subprocess.run(["bash", "-c", command])
    assert(result.returncode==0)

class Workspace:
    def __init__(self, root_directory):
        assert(os.path.isabs(root_directory))
        self.root_directory = root_directory
        opp_env_directory = os.path.join(self.root_directory, ".opp_env")
        if not os.path.exists(opp_env_directory):
            os.mkdir(opp_env_directory)

    def get_project_root_directory(self, project_description):
        return os.path.join(self.root_directory, project_description.get_full_folder_name())

    def is_project_downloaded(self, project_description):
        return os.path.exists(self.get_project_root_directory(project_description))

    def download_project(self, project_description):
        _logger.info(f"Downloading {project_description.get_full_name()} into {self.get_project_root_directory(project_description)}")
        run_command(project_description.download_command)

    def check_project_status(self, project_description):
        file_list_file_name = os.path.join(self.root_directory, ".opp_env/" + project_description.get_full_folder_name() + ".txt")
        md5_file_name = os.path.join(self.root_directory, ".opp_env/" + project_description.get_full_folder_name() + ".md5")
        if not os.path.exists(file_list_file_name):
            run_command(f"find {self.get_project_root_directory(project_description)} -type f | egrep -v '(bin/|doc/|ide/|media/|out/|results/|\\.log|\\.a|\\.so|\\.metadata|\\.jar|\\.png|\\.jpg)' > {file_list_file_name}")
            run_command(f"cat {file_list_file_name} | xargs -I ARG md5sum 'ARG' | sort | md5sum > {md5_file_name}")
        run_command(f"cat {file_list_file_name} | xargs -I ARG md5sum 'ARG' | sort | md5sum > {md5_file_name}.new")
        with open(md5_file_name, "r") as old_file:
            with open(md5_file_name + ".new", "r") as new_file:
                return COLOR_GREEN + "UNMODIFIED" + COLOR_RESET if old_file.read() == new_file.read() else COLOR_RED + "MODIFIED" + COLOR_RESET

class ProjectDescription:
    def __init__(self, name, version, description=None, stdenv="llvmPackages_14.stdenv", folder_name=None, required_projects={}, external_nix_packages=[], download_command=None, setenv_command=None, configure_command=None, build_command=None, clean_command=None):
        self.name = name
        self.version = version
        self.description = description
        self.stdenv = stdenv
        self.folder_name = folder_name or name
        self.required_projects = required_projects
        self.external_nix_packages = external_nix_packages
        self.download_command = download_command
        self.setenv_command = setenv_command
        self.configure_command = configure_command
        self.build_command = build_command
        self.clean_command = clean_command

    def __repr__(self):
        return self.get_full_name()

    def __str__(self):
        return self.get_full_name()

    def get_full_name(self, colored=False):
        return (COLOR_CYAN if colored else "") + self.name + "-" + self.version + (COLOR_RESET if colored else "")

    def get_full_folder_name(self):
        return f"{self.folder_name}-{self.version}"

def get_all_omnetpp_project_descriptions():
    import omnetpp_versions
    return [ProjectDescription(**e) for e in omnetpp_versions.get_all_omnetpp_versions()]

def get_all_inet_project_descriptions():
    import inet_versions
    return [ProjectDescription(**e) for e in inet_versions.get_all_inet_versions()]

def get_all_external_project_descriptions():
    with open(os.path.join(os.path.dirname(os.path.realpath(__file__)), "external_versions.json")) as f:
        return [ProjectDescription(**e) for e in json.load(f)]

all_project_descriptions = None

def get_all_project_descriptions():
    global all_project_descriptions
    if not all_project_descriptions:
        all_project_descriptions = [
            *get_all_omnetpp_project_descriptions(),
            *get_all_inet_project_descriptions(),
            *get_all_external_project_descriptions(),
        ]
    return all_project_descriptions

def find_project_description(project_reference):
    project_descriptions = [x for x in get_all_project_descriptions() if x.name == project_reference.name and x.version == project_reference.version]
    if len(project_descriptions) == 0:
         raise Exception("Project description not found for " + str(project_reference))
    elif len(project_descriptions) > 1:
         raise Exception("More than one project descriptions were found for " + str(project_reference))
    else:
        return project_descriptions[0]

class ProjectReference:
    def __init__(self, name, version):
        self.name = name
        self.version = version

    def __repr__(self):
        return self.get_full_name()

    def __str__(self):
        return self.get_full_name()

    @classmethod
    def parse(self, string):
        parts = string.split("-")
        return ProjectReference("-".join(parts[:-1]), parts[-1:][0])

    def get_full_name(self):
        return self.name + "-" + self.version

def compute_effective_project_descriptions(specified_project_descriptions):
    # 1. collect all required projects ignoring the project versions
    required_project_names = []
    for specified_project_description in specified_project_descriptions:
        required_project_names.append(specified_project_description.name)
        for project_name, project_versions in specified_project_description.required_projects.items():
            # maintains the proper ordering of required projects
            if project_name in required_project_names:
                required_project_names = [e for e in required_project_names if e != project_name]
            required_project_names.append(project_name)
    required_project_names.reverse()
    # print(required_project_names)
    # 2. collect all available project versions for all required projects separately
    available_project_versions = {}
    for required_project_name in required_project_names:
        project_versions = []
        for project_description in get_all_project_descriptions():
            if project_description.name == required_project_name:
                project_versions.append(project_description.version)
        available_project_versions[required_project_name] = project_versions
    # print(available_project_versions)
    # 3. iterate over all combinations of the available project versions for the different required projects
    sets = available_project_versions.values()
    keys = list(available_project_versions.keys())
    for combination in itertools.product(*sets):
        accept_combination = True
        selected_project_descriptions = []
        # 4. for each required project version combination check if it mathces all specified and required project criteria
        for i in range(len(combination)):
            selected_project_name = f"{keys[i]}-{combination[i]}"
            selected_project_description = find_project_description(ProjectReference.parse(selected_project_name))
            selected_project_descriptions.append(selected_project_description)
        # print(selected_project_descriptions)
        # 5. check if the specified project versions are included in the project version combination
        for specified_project_description in specified_project_descriptions:
            if not specified_project_description in selected_project_descriptions:
                accept_combination = False
                break
        # 6. check if one of the required project versions are included in the project version combination for all project versions
        for selected_project_description in selected_project_descriptions:
            for required_project_name, required_project_versions in selected_project_description.required_projects.items():
                accept_selected_project_description = False
                for required_project_version in required_project_versions:
                    required_project_description = find_project_description(ProjectReference.parse(required_project_name + "-" + required_project_version))
                    if required_project_description in selected_project_descriptions:
                        accept_selected_project_description = True
                if not accept_selected_project_description:
                    accept_combination = False
                    break
        if accept_combination:
            return selected_project_descriptions
    raise Exception("The specified set of project versions cannot be satisfied")

def nix_develop(workspace_directory, effective_project_descriptions, nix_packages, command, interactive=False, isolated=True, **kwargs):
    nix_develop_flake = """{
    inputs = {
        nixpkgs.url = "nixpkgs/nixos-22.11";
        flake-utils.url = "github:numtide/flake-utils";
    };
    outputs = { self, nixpkgs, flake-utils }:
    flake-utils.lib.eachDefaultSystem(system:
    let
        pkgs = import nixpkgs { inherit system; };
        in rec {
            devShells = rec {
                default = pkgs.@STDENV@.mkDerivation {
                    name = "@NAME@";
                    buildInputs = with pkgs; [ @PACKAGES@ ];
                    shellHook = ''
                        export QT_PLUGIN_PATH=${pkgs.qt5.qtbase.bin}/${pkgs.qt5.qtbase.qtPluginPrefix}:${pkgs.qt5.qtsvg.bin}/${pkgs.qt5.qtbase.qtPluginPrefix}
                        # disable GL support as NIX does not play nicely with OpenGL (except on nixOS)
                        export QT_XCB_GL_INTEGRATION=''${QT_XCB_GL_INTEGRATION:-none}

                        @SCRIPT@
                    '';
                };
            };
        });
}"""
    nix_develop_flake_file_name = os.path.join(workspace_directory, ".opp_env/flake.nix")
    omnetpp_project_description = next(filter(lambda project_description: project_description.name == "omnetpp", effective_project_descriptions))
    with open(nix_develop_flake_file_name, "w") as f:
        nix_develop_flake = nix_develop_flake.replace("@STDENV@", omnetpp_project_description.stdenv)
        nix_develop_flake = nix_develop_flake.replace("@NAME@", f"{'+'.join(map(str, effective_project_descriptions))}")
        nix_develop_flake = nix_develop_flake.replace("@PACKAGES@", " ".join(nix_packages))
        nix_develop_flake = nix_develop_flake.replace("@SCRIPT@", command)
        f.write(nix_develop_flake)
    nix_develop_command = f"nix develop {'-i -k HOME -k DISPLAY -k XDG_RUNTIME_DIR -k XDG_CACHE_HOME -k QT_AUTO_SCREEN_SCALE_FACTOR ' if isolated else ''} {os.path.join(workspace_directory, '.opp_env')} {'' if interactive else '-c true'}"
    run_command(nix_develop_command)

def list_subcommand_main(**kwargs):
    print("\n".join(map(str, get_all_project_descriptions())))

def describe_subcommand_main(project, **kwargs):
    project_description = find_project_description(ProjectReference.parse(project))
    print(repr(project_description))

def setup_environment(projects, isolated=True, workspace_directory=os.getcwd(), **kwargs):
    workspace = Workspace(workspace_directory)
    specified_project_references = list(map(ProjectReference.parse, projects))
    specified_project_descriptions = list(map(find_project_description, specified_project_references))
    effective_project_descriptions = compute_effective_project_descriptions(specified_project_descriptions)
    _logger.info(f"Setting up environment in {COLOR_CYAN + workspace_directory + COLOR_RESET} for {COLOR_CYAN + str(specified_project_references) + COLOR_RESET} as {COLOR_CYAN + str(effective_project_descriptions) + COLOR_RESET}")
    external_nix_packages = []
    project_setenv_commands = []
    downloaded_project_descriptions = []
    for project_description in effective_project_descriptions:
        if workspace.is_project_downloaded(project_description):
            _logger.info(f"{project_description.get_full_name(colored=True)} is {workspace.check_project_status(project_description)}")
        else:
            workspace.download_project(project_description)
            downloaded_project_descriptions.append(project_description)
        external_nix_packages += project_description.external_nix_packages
        project_setenv_commands.append(f"cd {workspace.get_project_root_directory(project_description)} && {project_description.setenv_command}")
    for downloaded_project_description in downloaded_project_descriptions:
        if downloaded_project_description.configure_command:
            nix_develop(workspace_directory, effective_project_descriptions, external_nix_packages, f"{' && '.join(project_setenv_commands)} && cd {workspace.get_project_root_directory(downloaded_project_description)} && {downloaded_project_description.configure_command}", isolated=isolated)
        if downloaded_project_description.build_command:
            nix_develop(workspace_directory, effective_project_descriptions, external_nix_packages, f"{' && '.join(project_setenv_commands)} && cd {workspace.get_project_root_directory(downloaded_project_description)} && {downloaded_project_description.build_command}", isolated=isolated)
    return effective_project_descriptions, external_nix_packages, project_setenv_commands

def build_subcommand_main(workspace_directory=os.getcwd(), **kwargs):
    workspace = Workspace(workspace_directory)
    effective_project_descriptions, external_nix_packages, project_setenv_commands = setup_environment(workspace_directory=workspace_directory, **kwargs)
    project_build_commands = []
    for project_description in effective_project_descriptions:
        project_build_commands.append(f"cd {workspace.get_project_root_directory(project_description)} && {project_description.build_command}")
    nix_develop(workspace_directory, effective_project_descriptions, external_nix_packages, f"{' && '.join(project_setenv_commands)} && {' && '.join(project_build_commands)}", **kwargs)

def clean_subcommand_main(workspace_directory=os.getcwd(), **kwargs):
    workspace = Workspace(workspace_directory)
    effective_project_descriptions, external_nix_packages, project_setenv_commands = setup_environment(workspace_directory=workspace_directory, **kwargs)
    project_clean_commands = []
    for project_description in effective_project_descriptions:
        project_clean_commands.append(f"cd {workspace.get_project_root_directory(project_description)} && {project_description.clean_command}")
    nix_develop(workspace_directory, effective_project_descriptions, external_nix_packages, f"{' && '.join(project_setenv_commands)} && {' && '.join(project_clean_commands)}", **kwargs)

def shell_subcommand_main(workspace_directory=os.getcwd(), **kwargs):
    effective_project_descriptions, external_nix_packages, project_setenv_commands = setup_environment(workspace_directory=workspace_directory, **kwargs)
    nix_develop(workspace_directory, effective_project_descriptions, external_nix_packages, f"pushd . > /dev/null && {' && '.join(project_setenv_commands)} && popd > /dev/null", interactive=True, **kwargs)

def run_subcommand_main(command=None,  workspace_directory=os.getcwd(), **kwargs):
    effective_project_descriptions, external_nix_packages, project_setenv_commands = setup_environment(workspace_directory=workspace_directory, **kwargs)
    nix_develop(workspace_directory, effective_project_descriptions, external_nix_packages, f"{' && '.join(project_setenv_commands)} && cd {workspace_directory} && {command}", **kwargs)

kwargs = process_arguments()
if (kwargs['subcommand'] == "list"):
    list_subcommand_main(**kwargs)
elif (kwargs['subcommand'] == "describe"):
    describe_subcommand_main(**kwargs)
elif (kwargs['subcommand'] == "build"):
    build_subcommand_main(**kwargs)
elif (kwargs['subcommand'] == "clean"):
    clean_subcommand_main(**kwargs)
elif (kwargs['subcommand'] == "shell"):
    shell_subcommand_main(**kwargs)
elif (kwargs['subcommand'] == "run"):
    run_subcommand_main(**kwargs)
