#!/usr/bin/env python3

import argparse
import itertools
import json
import logging
import os
import shlex
import subprocess
import sys

_logger = logging.getLogger(__file__)

COLOR_GRAY = "\033[38;20m"
COLOR_RED = "\033[1;31m"
COLOR_YELLOW = "\033[1;33m"
COLOR_CYAN = "\033[0;36m"
COLOR_GREEN = "\033[0;32m"
COLOR_RESET = "\033[0;0m"

class ColoredLoggingFormatter(logging.Formatter):
    COLORS = {
        logging.DEBUG: COLOR_GREEN,
        logging.INFO: COLOR_GREEN,
        logging.WARNING: COLOR_YELLOW,
        logging.ERROR: COLOR_RED,
        logging.CRITICAL: COLOR_RED
    }

    def format(self, record):
        format = self.COLORS.get(record.levelno) + "%(levelname)s " + "%(message)s"
        formatter = logging.Formatter(format)
        return formatter.format(record)

def parse_arguments():
    description = "Sets up the development environment for OMNeT++ projects"
    parser = argparse.ArgumentParser(description=description)
    parser.add_argument("-l", "--log-level", choices=["ERROR", "WARN", "INFO", "DEBUG"], default="INFO", help="Verbose output mode")
    parser.add_argument("-w", "--workspace", dest="workspace_directory", help="Workspace directory")
    subparsers = parser.add_subparsers(title="subcommands", dest="subcommand", required=True)

    parser_list = subparsers.add_parser("list", help="Lists all available projects")

    parser_shell = subparsers.add_parser("build", help="Builds the specified projects in their environment")
    parser_shell.add_argument("projects", nargs="+", help="List of projects")
    parser_shell.add_argument("-i", "--isolated", action=argparse.BooleanOptionalAction, default=True, help="Run in isolated environment from the host operating system")

    parser_shell = subparsers.add_parser("clean", help="Cleans the specified projects in their environment")
    parser_shell.add_argument("projects", nargs="+", help="List of projects")
    parser_shell.add_argument("-i", "--isolated", action=argparse.BooleanOptionalAction, default=True, help="Run in isolated environment from the host operating system")

    parser_shell = subparsers.add_parser("shell", help="Runs a shell in the environment of the specified projects")
    parser_shell.add_argument("projects", nargs="+", help="List of projects")
    parser_shell.add_argument("-i", "--isolated", action=argparse.BooleanOptionalAction, default=True, help="Run in isolated environment from the host operating system")

    parser_run = subparsers.add_parser("run", help="Runs a command in the environment of the specified projects")
    parser_run.add_argument("projects", nargs="+", help="List of projects")
    parser_run.add_argument("-i", "--isolated", action=argparse.BooleanOptionalAction, default=True, help="Run in isolated environment from the host operating system")
    parser_run.add_argument("-c", "--command", help="Specifies the commmand that is run in the environment")

    return parser.parse_args(sys.argv[1:])

def process_arguments():
    args = parse_arguments()
    handler = logging.StreamHandler()
    handler.setFormatter(ColoredLoggingFormatter())
    _logger.setLevel(args.log_level)
    _logger.handlers = []
    _logger.addHandler(handler)
    kwargs = {k: v for k, v in vars(args).items() if v is not None}
    if "workspace_directory" in kwargs:
        kwargs["workspace_directory"] = os.path.abspath(kwargs["workspace_directory"])
    return kwargs

def run_command(command):
    _logger.debug(f"Running command: {command}")
    result = subprocess.run(["bash", "-c", command])
    assert(result.returncode==0)

class Workspace:
    def __init__(self, root_directory):
        assert(os.path.isabs(root_directory))
        self.root_directory = root_directory
        opp_env_directory = os.path.join(self.root_directory, ".opp_env")
        if not os.path.exists(opp_env_directory):
            os.mkdir(opp_env_directory)

    def get_project_root_directory(self, project_description):
        return os.path.join(self.root_directory, project_description.get_full_folder_name())

    def is_project_downloaded(self, project_description):
        return os.path.exists(self.get_project_root_directory(project_description))

    def download_project(self, project_description):
        _logger.info(f"Downloading {project_description.get_full_name()} into {self.get_project_root_directory(project_description)}")
        run_command(project_description.download_command)

    def check_project_status(self, project_description):
        # return COLOR_GREEN + "UNMODIFIED" + COLOR_RESET
        # TODO du -k --exclude=\*results\* --exclude=out --exclude=media --exclude=work --exclude=\*.log --exclude=\*.so .
        # TODO du -k --exclude=out --exclude=.metadata exclude=\*results\* exclude=\*.so .

        file_list_file_name = os.path.join(self.root_directory, ".opp_env/" + project_description.get_full_folder_name() + ".txt")
        md5_file_name = os.path.join(self.root_directory, ".opp_env/" + project_description.get_full_folder_name() + ".md5")
        if not os.path.exists(file_list_file_name):
            run_command(f"find {self.get_project_root_directory(project_description)} -type f > {file_list_file_name}")
            run_command(f"cat {file_list_file_name} | xargs -I ARG md5sum 'ARG' | sort | md5sum > {md5_file_name}")
        run_command(f"cat {file_list_file_name} | xargs -I ARG md5sum 'ARG' | sort | md5sum > {md5_file_name}.new")
        with open(md5_file_name, "r") as old_file:
            with open(md5_file_name + ".new", "r") as new_file:
                return COLOR_GREEN + "UNMODIFIED" + COLOR_RESET if old_file.read() == new_file.read() else COLOR_RED + "MODIFIED" + COLOR_RESET

class ProjectDescription:
    def __init__(self, name, version, stdenv="llvmPackages_14.stdenv", folder_name=None, required_projects={}, external_nix_packages=[], download_command=None, setenv_command=None, configure_command=None, build_command=None, clean_command=None):
        self.name = name
        self.version = version
        self.stdenv = stdenv
        self.folder_name = folder_name or name
        self.required_projects = required_projects
        self.external_nix_packages = external_nix_packages
        self.download_command = download_command
        self.setenv_command = setenv_command
        self.configure_command = configure_command
        self.build_command = build_command
        self.clean_command = clean_command

    def __repr__(self):
        return self.get_full_name()

    def __str__(self):
        return self.get_full_name()

    def get_full_name(self, colored=False):
        return (COLOR_CYAN if colored else "") + self.name + "-" + self.version + (COLOR_RESET if colored else "")

    def get_full_folder_name(self):
        return f"{self.folder_name}-{self.version}"

def get_all_omnetpp_project_descriptions():
    import omnetpp_versions
    return [ProjectDescription(**e) for e in omnetpp_versions.get_all_omnetpp_versions()]

def get_all_inet_project_descriptions():
    import inet_versions
    return [ProjectDescription(**e) for e in inet_versions.get_all_inet_versions()]

def get_all_external_project_descriptions():
    with open(os.path.join(os.path.dirname(os.path.realpath(__file__)), "external_versions.json")) as f:
        return [ProjectDescription(**e) for e in json.load(f)]

def get_all_project_descriptions():
    return [
        *get_all_omnetpp_project_descriptions(),
        *get_all_inet_project_descriptions(),
        *get_all_external_project_descriptions(),
    ]

def find_project_description(project_reference):
    project_descriptions = [x for x in get_all_project_descriptions() if x.name == project_reference.name and x.version == project_reference.version]
    if len(project_descriptions) == 0:
         raise Exception("Project description not found for " + str(project_reference))
    elif len(project_descriptions) > 1:
         raise Exception("More than one project descriptions were found for " + str(project_reference))
    else:
        return project_descriptions[0]

class ProjectReference:
    def __init__(self, name, version):
        self.name = name
        self.version = version

    def __repr__(self):
        return self.get_full_name()

    def __str__(self):
        return self.get_full_name()

    @classmethod
    def parse(self, string):
        parts = string.split("-")
        return ProjectReference("-".join(parts[:-1]), parts[-1:][0])

    def get_full_name(self):
        return self.name + "-" + self.version

def compute_effective_project_descriptions(specified_project_descriptions):
    effective_project_descriptions = []
    for specified_project_description in specified_project_descriptions:
        effective_project_descriptions.append(specified_project_description)
        required_projects = specified_project_description.required_projects
        for k, v in required_projects.items():
            required_project_description = find_project_description(ProjectReference.parse(k + "-" + v[0]))
            effective_project_descriptions += compute_effective_project_descriptions([required_project_description])
    effective_project_descriptions.reverse()
    return list(set(effective_project_descriptions))

def nix_develop(workspace_directory, effective_project_descriptions, nix_packages, command, interactive=False, isolated=True, **kwargs):
    nix_develop_flake = """{
    inputs = {
        nixpkgs.url = "nixpkgs/nixos-22.11";
        flake-utils.url = "github:numtide/flake-utils";
    };
    outputs = { self, nixpkgs, flake-utils }:
    flake-utils.lib.eachDefaultSystem(system:
    let
        pkgs = import nixpkgs { inherit system; };
        in rec {
            devShells = rec {
                default = pkgs.@STDENV@.mkDerivation {
                    name = "@NAME@";
                    buildInputs = with pkgs; [ @PACKAGES@ ];
                    shellHook = ''
                        @SCRIPT@
                    '';
                };
            };
        });
}"""
    nix_develop_flake_file_name = os.path.join(workspace_directory, ".opp_env/flake.nix")
    omnetpp_project_description = next(filter(lambda project_description: project_description.name == "omnetpp", effective_project_descriptions))
    with open(nix_develop_flake_file_name, "w") as f:
        nix_develop_flake = nix_develop_flake.replace("@STDENV@", omnetpp_project_description.stdenv)
        nix_develop_flake = nix_develop_flake.replace("@NAME@", f"{'+'.join(map(str, effective_project_descriptions))}")
        nix_develop_flake = nix_develop_flake.replace("@PACKAGES@", " ".join(nix_packages))
        nix_develop_flake = nix_develop_flake.replace("@SCRIPT@", command)
        f.write(nix_develop_flake)
    nix_develop_command = f"nix develop {'-i' if isolated else ''} {os.path.join(workspace_directory, '.opp_env')} {'' if interactive else '-c true'}"
    run_command(nix_develop_command)

def list_subcommand_main(**kwargs):
    print("\n".join(map(str, get_all_project_descriptions())))

def setup_environment(projects, isolated=True, workspace_directory=os.getcwd(), **kwargs):
    workspace = Workspace(workspace_directory)
    specified_project_references = list(map(ProjectReference.parse, projects))
    specified_project_descriptions = list(map(find_project_description, specified_project_references))
    effective_project_descriptions = compute_effective_project_descriptions(specified_project_descriptions)
    _logger.info(f"Setting up environment in {COLOR_CYAN + workspace_directory + COLOR_RESET} for {COLOR_CYAN + str(specified_project_references) + COLOR_RESET} as {COLOR_CYAN + str(effective_project_descriptions) + COLOR_RESET}")
    external_nix_packages = []
    project_setenv_commands = []
    downloaded_project_descriptions = []
    for project_description in effective_project_descriptions:
        if workspace.is_project_downloaded(project_description):
            _logger.info(f"{project_description.get_full_name(colored=True)} is {workspace.check_project_status(project_description)}")
        else:
            workspace.download_project(project_description)
            downloaded_project_descriptions.append(project_description)
        external_nix_packages += project_description.external_nix_packages
        project_setenv_commands.append(f"cd {workspace.get_project_root_directory(project_description)} && {project_description.setenv_command}")
    for downloaded_project_description in downloaded_project_descriptions:
        if downloaded_project_description.configure_command:
            nix_develop(workspace_directory, effective_project_descriptions, external_nix_packages, f"{' && '.join(project_setenv_commands)} && cd {workspace.get_project_root_directory(downloaded_project_description)} && {downloaded_project_description.configure_command}", isolated=isolated)
        if downloaded_project_description.build_command:
            nix_develop(workspace_directory, effective_project_descriptions, external_nix_packages, f"{' && '.join(project_setenv_commands)} && cd {workspace.get_project_root_directory(downloaded_project_description)} && {downloaded_project_description.build_command}", isolated=isolated)
    return effective_project_descriptions, external_nix_packages, project_setenv_commands

def build_subcommand_main(workspace_directory=os.getcwd(), **kwargs):
    workspace = Workspace(workspace_directory)
    effective_project_descriptions, external_nix_packages, project_setenv_commands = setup_environment(workspace_directory=workspace_directory, **kwargs)
    project_build_commands = []
    for project_description in effective_project_descriptions:
            project_build_commands.append(f"cd {workspace.get_project_root_directory(project_description)} && {project_description.build_command}")
    nix_develop(workspace_directory, effective_project_descriptions, external_nix_packages, f"{' && '.join(project_setenv_commands)} && {' && '.join(project_build_commands)}", **kwargs)

def clean_subcommand_main(workspace_directory=os.getcwd(), **kwargs):
    workspace = Workspace(workspace_directory)
    effective_project_descriptions, external_nix_packages, project_setenv_commands = setup_environment(workspace_directory=workspace_directory, **kwargs)
    project_clean_commands = []
    for project_description in effective_project_descriptions:
        project_clean_commands.append(f"cd {workspace.get_project_root_directory(project_description)} && {project_description.clean_command}")
    nix_develop(workspace_directory, effective_project_descriptions, external_nix_packages, f"{' && '.join(project_setenv_commands)} && {' && '.join(project_clean_commands)}", **kwargs)

def shell_subcommand_main(workspace_directory=os.getcwd(), **kwargs):
    effective_project_descriptions, external_nix_packages, project_setenv_commands = setup_environment(workspace_directory=workspace_directory, **kwargs)
    nix_develop(workspace_directory, effective_project_descriptions, external_nix_packages, f"pushd . > /dev/null && {' && '.join(project_setenv_commands)} && popd > /dev/null", interactive=True, **kwargs)

def run_subcommand_main(command=None,  workspace_directory=os.getcwd(), **kwargs):
    effective_project_descriptions, external_nix_packages, project_setenv_commands = setup_environment(workspace_directory=workspace_directory, **kwargs)
    nix_develop(workspace_directory, effective_project_descriptions, external_nix_packages, f"{' && '.join(project_setenv_commands)} && cd {workspace_directory} && {command}", **kwargs)

kwargs = process_arguments()
if (kwargs['subcommand'] == "list"):
    list_subcommand_main(**kwargs)
elif (kwargs['subcommand'] == "build"):
    build_subcommand_main(**kwargs)
elif (kwargs['subcommand'] == "clean"):
    clean_subcommand_main(**kwargs)
elif (kwargs['subcommand'] == "shell"):
    shell_subcommand_main(**kwargs)
elif (kwargs['subcommand'] == "run"):
    run_subcommand_main(**kwargs)
